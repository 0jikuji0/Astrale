<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tiles Earth - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }
        #controls h3 {
            margin: 0 0 10px 0;
        }
        #controls p {
            margin: 5px 0;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">Chargement du mod√®le 3D...</div>
    <div id="controls">
        <h3>üåç Contr√¥les</h3>
        <p><strong>Clic gauche + glisser</strong> : Rotation</p>
        <p><strong>Molette</strong> : Zoom</p>
        <p><strong>Clic droit + glisser</strong> : D√©placement</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, earth;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isDragging = false;

        function init() {
            // Sc√®ne
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Cam√©ra
            camera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 5;

            // Renderer
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Lumi√®res
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            // Cr√©er la Terre avec texture
            createEarth();

            // Ajouter des √©toiles
            addStars();

            // √âv√©nements
            window.addEventListener('resize', onWindowResize);
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);

            // Masquer le message de chargement
            document.getElementById('loading').style.display = 'none';

            animate();
        }

        function createEarth() {
            // G√©om√©trie de la sph√®re
            const geometry = new THREE.SphereGeometry(1, 64, 64);

            // Charger la texture de la Terre
            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load(
                'https://unpkg.com/three-globe@2.24.4/example/img/earth-blue-marble.jpg',
                () => {
                    console.log('Texture charg√©e');
                }
            );

            // Mat√©riau avec texture
            const material = new THREE.MeshPhongMaterial({
                map: earthTexture,
                shininess: 10
            });

            earth = new THREE.Mesh(geometry, material);
            scene.add(earth);

            // Rotation initiale pour voir l'Am√©rique
            earth.rotation.y = -Math.PI / 2;
        }

        function addStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.01
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute(
                'position',
                new THREE.Float32BufferAttribute(starsVertices, 3)
            );

            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        function onMouseDown(e) {
            isDragging = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        function onMouseMove(e) {
            if (isDragging) {
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;

                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;

                // Limiter la rotation verticale
                targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));

                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWheel(e) {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.001;
            camera.position.z = Math.max(5, Math.min(30, camera.position.z));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotation fluide
            if (earth) {
                earth.rotation.y += (targetRotationY - earth.rotation.y) * 0.1;
                earth.rotation.x += (targetRotationX - earth.rotation.x) * 0.1;

                // Auto-rotation lente si pas de drag
                if (!isDragging) {
                    earth.rotation.y += 0.001;
                }
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>